Shift up non missing values read backwards dow

   1. DOW datastep - read ahead
   2. read backward then carry forward and fip again
   3  Interpolating values in a timeseries when some first,last and middle values are missing
      see https://goo.gl/iQn3nU
      https://communities.sas.com/t5/SAS-Procedures/shifts-up-not-missing-variables/m-p/515208
      
      Recent solutions on end by

      Bartosz Jablonski
      yabwon@gmail.com

    4. HASH soultion
    5. Array Solution

github
https://tinyurl.com/ycwdt2kf
https://github.com/rogerjdeangelis/utl-shift-up-non-missing-values-read-backwards-dow

SAS Forum
https://communities.sas.com/t5/SAS-Procedures/shifts-up-not-missing-variables/m-p/515208

R has a function to do this lead and lag?


INPUT
=====

 WORK.HAVE total obs=8

                |  RULES
 VAR1    VAR2   |  VAR2
                |
   1       .    |   4
   2       .    |   4
   4       .    |   4
   5       4    |   4  ** carry 4 backwards

   3       9    |   9  ** leave alone

   3       .    |   5
   3       .    |   5
   6       5    |   5  ** carry 5 backwards
                |

EXAMPLE OUTPUT
---------------

WORK WANT total obs=8

 VAR1    VAR2

   1       4
   2       4
   4       4
   5       4
   3       9
   3       5
   3       5
   6       5



PROCESS
=======


1. DOW datastep - read ahead
-----------------------------

data want;

  retain var2Sav pnt 0;

  do until (last.var2);

    set have;

    by var2 notsorted;

    pnt=pnt+1;

    if last.var2 and var2=. then do;
       * get value after last missing;
       pnt=pnt+1;
       set have point=pnt;
       var2Sav=var2;
       pnt=pnt-1; * RESET FOR NEXT ITERATIONS;
    end;

   end;

   do until (last.var2);
      set have;
      by var2 notsorted;
      if var2=. then var2=Var2Sav;
      output;
   end;

   var2Sav=0;

run;quit;


2. read backward then carry forward and fip again
--------------------------------------------------

proc datasets lib=work;
 delete havRev havFil want:;
run;quit;

data want(drop=var2 rename=varSav=var2);

  * read backards and carr forward;
  if _n_=0 then do; %let rc=%sysfunc(dosubl('
     data havRev; * unable to mahe this a view;
        if _n_=0 then set have nobs=numObs;
        set have point=numObs;
        if numObs=0 then stop;
        output;
        numObs=numObs-1;
     run;quit;
     data havFil;
       retain varSav;
       set havRev end=dne;
       if var2 ne . then varSav=var2;
    run;quit;
    '));
  end;

  if _n_=0 then set have nobs=numObs;

  set havFil point=numObs;
  if numObs=0 then stop;
  output;

  numObs=numObs-1;

run;quit;


3  Interpolating values in a timeseries when some first,last and middle values are missing
-------------------------------------------------------------------------------------------

   see https://goo.gl/iQn3nU


OUTPUT
======

see above

*                _               _       _
 _ __ ___   __ _| | _____     __| | __ _| |_ __ _
| '_ ` _ \ / _` | |/ / _ \   / _` |/ _` | __/ _` |
| | | | | | (_| |   <  __/  | (_| | (_| | || (_| |
|_| |_| |_|\__,_|_|\_\___|   \__,_|\__,_|\__\__,_|

;

data have;
 input var1 var2;
cards4;
1 .
2 .
4 .
5 4
3 9
3 .
3 .
6 5
;;;;
run;quit;

*____             _
| __ )  __ _ _ __| |_
|  _ \ / _` | '__| __|
| |_) | (_| | |  | |_
|____/ \__,_|_|   \__|

;

Recent solutions on end by

Bartosz Jablonski
yabwon@gmail.com

 4. HASH soultion
 5. Array Solution


4. HASH soultion
----------------

data _null_;
  declare hash H(ordered:"a");
  H.defineKey("curobs");
  H.defineData("curobs");
  H.defineData("var1");
  H.defineData("var2");
  H.defineDone();
  declare hiter I("H");

  do until(EOF);
   set have end=EOF curobs=curobs;
   H.add();
  end;

  do while(I.prev()=0);
    if var2 ne . then _t2 = var2;
                 else var2 = _t2;
    H.replace();
  end;

  H.output(dataset:"want(drop=curobs)");
  stop;
run;


5. Array Solution
-----------------

data _null_;
  set have nobs=nobs;
  call symputX("nobs", nobs, "G");
  stop;
run;

data want2;
  array arr1_[&nobs.] _temporary_;
  array arr2_[&nobs.] _temporary_;

  do until(EOF);
   set have end=EOF curobs=curobs;
   arr1_[curobs] = var1;
   arr2_[curobs] = var2;
  end;

  do _N_ = dim(arr1_) to 1 by -1; drop _t2;
    if arr2_[_N_] ne . then _t2 = arr2_[_N_];
                       else arr2_[_N_] = _t2;
  end;

  do _N_ = 1 to dim(arr1_) by 1;
    var1 = arr1_[_N_];
    var2 = arr2_[_N_];
    output;
  end;

  stop;
run;




